# .cursorrules

## Contexte de l'application

organise les fichiers par features. Les composants d'une meme features doivent être préfixé pareil (du nom de leur features). Un fichier ne doit pas dépasser 250 lignes.

Cette application est conçue pour la rééducation de personnes ayant subi un AVC (Accident Vasculaire Cérébral). Par conséquent, l'interface doit être :
- **Simple** : Navigation claire, actions évidentes, pas de complexité inutile
- **Intuitive** : Flux logiques, feedback immédiat, pas de confusion possible
- **Accessible** : Respect des standards WCAG, navigation au clavier, contrastes élevés, textes lisibles, support des lecteurs d'écran
- **Encourageante** : Feedback positif, célébration des réussites, progression visible, messages motivants

Chaque décision de design et d'implémentation doit être évaluée selon ces critères prioritaires.

## Next.js App Router

- Use App Router structure: `app/` directory with `page.tsx`, `layout.tsx`, `route.ts` files
- Server Components by default: Only add `'use client'` when needed (interactivity, hooks, browser APIs)
- Route components: Use `export default function PageName()` for page components
- API Routes: Use `app/api/` directory with `route.ts` files, export named functions (`GET`, `POST`, etc.)
- Metadata: Export `metadata` object for static metadata, use `generateMetadata` function for dynamic metadata
- Layouts: Use `layout.tsx` for shared layouts, can be nested
- Loading states: Use `loading.tsx` for loading UI
- Error handling: Use `error.tsx` for error boundaries
- Navigation: Use `Link` from `next/link` for client-side navigation, `useRouter` from `next/navigation` for programmatic navigation, `usePathname` for current path

```typescript
// ✅ GOOD - Server Component (default)
export default function Page() {
  return <div>Content</div>;
}

// ✅ GOOD - Client Component (when needed)
'use client';
export default function InteractivePage() {
  const [state, setState] = useState();
  return <div>Interactive content</div>;
}

// ✅ GOOD - API Route
export async function GET(request: Request) {
  return Response.json({ data: 'value' });
}

// ✅ GOOD - Metadata
export const metadata: Metadata = {
  title: 'Page Title',
};

// ❌ BAD - Unnecessary client component
'use client';
export default function StaticPage() {
  return <div>Static content</div>;
}
```

## TypeScript React - Props Declaration

- ALWAYS use `type Props = { ... }` (NEVER `interface`)
- Props are local and non-exported by default
- Direct destructuring in function signature
- For children: `PropsWithChildren<{ ... }>`
- Extension by intersection: `type Props = BaseType & { ... }`
- Import types: `import { type ReactNode } from 'react'`

❌ Forbidden:
- Never `interface` for props
- Never inline props
- Never systematic export of props

## Keys in map loops

- Priority 1: Use unique ID if available: `key={item.id}`
- Priority 2: Use unique property if no ID: `key={item.value}`, `key={item.loinc}`, etc.
- Priority 3: Use composite key only if needed: `key={`${date}-${kind}`}`
- Avoid: Using index alone (only in very specific cases)

```typescript
// ✅ GOOD - Using ID
{items.map(item => <div key={item.id}>...</div>)}

// ✅ GOOD - Using unique property
{items.map(item => <div key={item.value}>...</div>)}

// ✅ GOOD - Composite key when needed
{items.map(item => <div key={`${item.date}-${item.kind}`}>...</div>)}

// ❌ BAD - Index alone (avoid)
{items.map((item, index) => <div key={index}>...</div>)}
```

## Tailwind conditional styles

- Always use clsx for conditional classes
- Import: `import clsx from 'clsx'`

## Component naming and exports

- Use PascalCase for component names: `export function ComponentName`
- Prefer named exports over default exports for components
- Use default exports for Next.js route components (`page.tsx`, `layout.tsx`) and API route handlers (`route.ts`)
- Components are functions, not arrow functions: `export function MyComponent() {}`

```typescript
// ✅ GOOD
export function MyComponent({ prop1, prop2 }: Props) {
  return <div>...</div>;
}

// ❌ BAD - Arrow function
export const MyComponent = ({ prop1, prop2 }: Props) => {
  return <div>...</div>;
}
```

## Custom hooks

- Always start with `use` prefix: `usePatientData`, `useUpdateDocument`
- Return objects, not tuples: `return { data, loading, error }`
- Organize hooks in folders: `hooks/api/`, `hooks/query-state/`
- Use `useCallback` for functions returned from hooks that are used as dependencies

```typescript
// ✅ GOOD
export function useUpdateDocument() {
  const update = useCallback((id: string) => {
    // ...
  }, []);
  
  return { update };
}

// ❌ BAD - Tuple return
export function useUpdateDocument() {
  return [update, loading];
}
```

## React imports

- Use `import type` for type-only imports: `import type { ReactNode } from 'react'`
- Import hooks directly: `import { useState, useCallback } from 'react'`
- Use `PropsWithChildren` from React for components with children

```typescript
// ✅ GOOD
import { useState, useCallback, type ReactNode } from 'react';
import type { PropsWithChildren } from 'react';

// ❌ BAD - No type import
import { useState, ReactNode } from 'react';
```

## Error handling

- **Always prefer `throw new Error('context')` over simple `return`** for validations and checks
- Throw errors for expected error cases with descriptive context: `throw new Error('Missing documentId param')`
- Use Next.js `error.tsx` files for error boundaries at route level
- Use `notFound()` from `next/navigation` for 404 cases
- Don't catch errors to silently fail - let them bubble up
- Error messages should provide clear context about what went wrong

```typescript
// ✅ GOOD - Throw with context
if (!params.documentId) {
  throw new Error('Missing documentId param');
}

if (!patient) {
  throw new Error('Patient not found');
}

if (!response.ok) {
  throw new Error(`Failed to fetch data: ${response.status}`);
}

// ❌ BAD - Silent failure with return
if (!params.documentId) {
  return null;
}

if (!patient) {
  return;
}

// ❌ BAD - Return without error context
if (!response.ok) {
  return undefined;
}
```

## Performance optimizations

- Use `useCallback` for functions passed as props or in dependency arrays
- Use `useMemo` for expensive computations
- Use `use` hook for React Context (React 19): `const value = use(MyContext)`

```typescript
// ✅ GOOD
const handleClick = useCallback(() => {
  // ...
}, [dependency]);

const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);
```

## Context providers

- Export Context and Provider separately
- Use `PropsWithChildren` for Provider props
- Pattern: `MyContext` + `MyProvider` + `useMyContext` hook

```typescript
// ✅ GOOD
export const MyContext = createContext<MyValue>(defaultValue);

export function MyProvider({ children }: PropsWithChildren) {
  const value = useMyValue();
  return <MyContext.Provider value={value}>{children}</MyContext.Provider>;
}
```


## Dependencies - Version Management

- When adding a new dependency, you must **always pin** its version in `package.json` (e.g., `"my-lib": "1.2.3"` and **never** `"my-lib": "^1.2.3"` or `"my-lib": "~1.2.3"`).
- Also pin all internal monorepo dependencies when they are changed or added.

```json
// ✅ GOOD - strictly pinned version
"my-lib": "1.2.3"

// ❌ BAD - version with caret (^) or tilde (~)
"my-lib": "^1.2.3"
"my-lib": "~1.2.3"
```


## Commit conventions

- Always follow [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/#specification) specification
- Format: `<type>(<scope>): <description>`
- Each commit message should consist of a header, optional body, and optional footer

### Commit structure

1. **Type:** Must be one of the following:
   - **build**: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)
   - **ci**: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)
   - **docs**: Documentation only changes
   - **feat**: A new feature
   - **fix**: A bug fix
   - **perf**: A code change that improves performance
   - **refactor**: A code change that neither fixes a bug nor adds a feature
   - **style**: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
   - **test**: Adding missing tests or correcting existing tests

2. **Scope:** Optional, refers to the scope of the commit. Should be specific to the feature/module being changed (e.g., `clinical-data`, `forms`, `modals`, `api`, `domain`). Avoid using the app name (e.g., `okeiro`) as it's too broad - use the specific module/feature name instead.

3. **Subject:** Brief description of the change in imperative mood, lowercase, no period at the end

4. **Body and Footer:** Optional, used to provide more detailed descriptions about the change and any breaking changes or issues closed by the commit

5. **BREAKING CHANGE:** A commit that has a footer `BREAKING CHANGE:`, or appends a `!` after the type/scope, introduces a breaking API change (correlating with **`MAJOR`** in Semantic Versioning). A BREAKING CHANGE can be part of commits of any *type*.

```bash
# ✅ GOOD
feat(TECH-123): add new login button
feat(ui): add chat message preview component
fix(api): resolve authentication token expiration
docs: update README with setup instructions
refactor(domain): simplify patient data model
build(npm): update dependencies

# ✅ GOOD - With specific scope
feat(clinical-data): implement messaging conversation view
fix(forms): handle database connection timeout
fix(api): resolve authentication token expiration

# ❌ BAD - Scope too broad (app name)
feat(okeiro): implement messaging conversation view
fix(okeiro): handle database connection timeout

# ✅ GOOD - Breaking change
feat(api)!: change authentication endpoint
feat(api): change authentication endpoint

BREAKING CHANGE: The /auth endpoint now requires a different payload structure

# ❌ BAD - Not following conventions
Added new feature
fix bug
Update README.md
```

- After making changes, always propose a commit message following these conventions 


### **. General Rules**

1. **Follow Standard Conventions**: Adhere to the coding standards and conventions that are prevalent for the languages and tools we use.
2. **Keep It Simple**: Always prefer simpler solutions. Reduce complexity wherever possible.
3. **Boy Scout Rule**: Always leave the code cleaner than you found it. Refactor or clean up every time you make changes.
4. **Root Cause Analysis**: Always strive to find and fix the root cause of a defect, not just the symptoms.
5. **Use Existing Hooks First**: Always check for and prioritize using existing hooks in the codebase before fetching data directly or passing data through props. Search the codebase for relevant hooks (e.g., `usePractitionerFragment`, `useOrganization`) and use them to access data within components.

### **B. Design Rules**

1. **Feature Isolation**: A component outside a feature (`components/`) must never import elements from a feature (`features/`). If a component uses feature-specific elements, it must be placed within that feature and prefixed with the feature name (e.g., `transplant-document-status-badge.tsx` in `features/patient-transplant-files/components/`).
2. **High-Level Configuration**: Keep configurable data at high levels in the code to enhance flexibility.
3. **Separate Multi-threading**: Isolate multi-threading code to manage complexity and enhance maintainability.
4. **Limit Over-Configurability**: Avoid excessive configurability which can lead to complex and unmanageable code.
5. **Use Dependency Injection**: Favor dependency injection to manage dependencies cleanly and flexibly.
6. **Law of Demeter**: Follow the Law of Demeter; a module should only know about direct dependencies.

### **C. Understandability Tips**

1. **Consistency**: If you do something one way, do all similar things in the same way.
2. **Explanatory Variables**: Use explanatory variables to clarify the purpose of complex expressions. 
3. **Encapsulate Boundary Conditions**: Centralize the handling of boundary conditions in a single location.
4. **Avoid Logical Dependencies**: Ensure methods do not have hidden dependencies on internal class state.

### **D. Naming Rules**

1. Everything in english, always. 
2. At least 3 characters rules for naming, unless it’s very explicit with less. 
3. Avoid acronyms at all cost ⬇️
4. **Descriptive Names**: Choose names that describe their purpose or behavior.
5. **Meaningful Distinctions**: Distinguish names in a way that clarifies their differences.
6. **Pronounceable and Searchable Names**: Use names that are easy to pronounce and search through code.
7. **Replace Magic Numbers**: Use named constants instead of magic numbers to enhance readability.

### **E. Function Rules**

1. **Small and Focused**: Functions should be small and focused on a single task.
2. **Descriptive Names**: Function names should clearly describe their behavior.
3. **Limit Arguments**: If possible prefer fewer arguments for simplicity and clarity.
4. **No Side Effects**: Functions should not have side effects. They should not modify any state not contained within them.

### **F. Commenting Rules**

1. **Don’t comment code :** There is no reason to push commented code, if a code is commented it is not used and therefore should not be present. 
2. **Explain Why, Not What**: Use comments to explain why something is done, not what is done.
3. **Avoid Redundant Comments**: Don't add comments that just repeat what the code does.
4. **Clarify Complex Code**: Use comments to clarify complex code operations or decisions.
5. **Intent and Warnings**: Document the intent behind decisions and warn about potential consequences.

### **G. Source Code Structure**

1. **Vertical Separation**: Separate concepts vertically in the code for better readability.
2. **Related Code Should Be Close**: Keep related functions and variables close to each other.
3. **Declare Variables Close to Usage**: Declare variables close to where they are used.
4. **Logical Flow**: Arrange functions in a logical flow downwards, callers above callees.